class Ball{
    // Responsibilities:
    // - Manage the ball's position and velocity.
    // - Detect and handle collisions with walls and paddles.
    // - Reset the ball after scoring.

    // constants.
    field int x;
    field int y;
    field int r;
    // fields
    field int velX;
    field int velY;

    // Ctor
    constructor Ball new(int velocity) {
        let x = 512 / 2; // half screen width
        let y = (256 / 2) + 16; // half screen height
        let r = 5;

        let velX = velocity; // Initial horizontal direction
        let velY = 0; // TODO
        return this;
    }

    method boolean isPosLegal(){
        var int xr, xl, yt, yb;
        var boolean xInRangeL, yInRangeT, xInRangeR, yInRangeB;
        let xr = x+r;
        let xl=x-r;
        let yt=y-r;
        let yb=y+r;
        // left
        if ((xl > 1) | (xl = 1)) { let xInRangeL = true; }
        else { let xInRangeL = false; }

        // right
        if ((xr = 510) | (xr < 510)) { let xInRangeR = true; }
        else { let xInRangeR = false; }

        // top
        if ((yt > 16) | (yt = 16)) { let yInRangeT = true; }
        else { let yInRangeT = false; }

        // bottom
        if ((yb < 250) | (yb = 250)) { let yInRangeB = true; }
        else { let yInRangeB = false; }

        // overall
        if (xInRangeL & xInRangeR & yInRangeT & yInRangeB) {
            // do Output.moveCursor(0, 20);
            // do Output.printString("x:");
            // do Output.printInt(x);
            // do Output.printString(" y:");
            // do Output.printInt(y);
            // do Output.printString(" r:");
            // do Output.printInt(r);
            // do Output.printString(" good");
            return true;
        } else {
            do Output.moveCursor(0, 20);
            do Output.printString("x:");
            do Output.printInt(x);
            do Output.printString(" y:");
            do Output.printInt(y);
            do Output.printString(" r:");
            do Output.printInt(r);
            do Output.printString(" bad");
            return false;
        }
    }

    method void draw() {
        do Screen.setColor(true);
        do Screen.drawCircle(x, y, r);
        return;
    }

    method void erase() {
        do Screen.setColor(false);
        do Screen.drawCircle(x, y, r);
        return;
    }

    method void move () {
        if(~(isPosLegal())){
            do flipVelX();
        }
        // erase cur loc
        do erase();
        // update ball loc with vel
        let x = x + velX;
        let y = y + velY;
        // draw ball again
        do draw();
        // TODO: check wall collisions here
        return;
    }

    method boolean checkOverlap(Paddle paddle) {
        // collision: if ball y between paddle top and bottom        
        //      and x in paddle width
        // ball borders
        var int xr, xl, yt, yb;
        // paddle booleans
        var boolean isInXR;
        var boolean isInXL;
        var boolean isInYT;
        var boolean isInYB;
        //
        let xr = x+r;
        let xl=x-r;
        let yt=y-r;
        let yb=y+r;
        //
        if (xl > paddle.getX() | xl = paddle.getX())
        { let isInXL = true; }
        else{let isInXL = false;}

        if (xr < paddle.getX()+paddle.getWidth() | xr = paddle.getX()+paddle.getWidth())
        { let isInXR = true; }
        else{let isInXR = false;}
        //TOO: bug here maybe. no score update when paddle is ABOVE ball.
        if (yb > paddle.getY())  { let isInYT=true; }
        else{ let isInYT=false; }
        
        if (yt < paddle.getY()+paddle.getHeight())  { let isInYB=true; }
        else{ let isInYB=false; }
        // check
        if (isInXR & isInXL & isInYB & isInYT)  { return true; }
        else { return false;}
    }

    // /**
    // return: 0 for no collision; 1 for collision with left, 2 for collision with right.
    // */
    // method int checkCollision (Paddle leftPaddle, Paddle rightPaddle) {
    //     var int xr, xl, yt, yb;
    //     // w/ right
    //     var boolean isBehindR;
    //     var boolean isAboveRightTop;
    //     var boolean isBelowRightBottom;
    //     // 
    //     var boolean isBehindL;
    //     var boolean isAboveLeftTop;
    //     var boolean isBelowLeftBottom;
    //     let xr = x+r;
    //     let xl=x-r;
    //     let yt=y-r;
    //     let yb=y+r;
    //     // assign
    //     if (xr > rightPaddle.getX() | xr = rightPaddle.getX()) {
    //         let isBehindR = true;
    //     } else {
    //         let isBehindR = false;
    //     }
    //     if (yt > rightPaddle.getY() | yt = rightPaddle.getY()) {
    //         let isAboveRightTop = true;
    //     } else {
    //         let isAboveRightTop = false;
    //     }
    //     if (yb < (rightPaddle.getY() + rightPaddle.getHeight()) | yb = (rightPaddle.getY() + rightPaddle.getHeight())) {
    //         let isBelowRightBottom = true;
    //     } else {
    //         let isBelowRightBottom = false;
    //     }
    //     // check
    //     if ((isBehindR) & (isAboveRightTop) & (isBelowRightBottom)) {
    //         return 2;
    //     }
    //     // w/ left
    //     // assign
    //     if (xl = leftPaddle.getX() | xl < leftPaddle.getX() + leftPaddle.getWidth() | xl = leftPaddle.getX() + leftPaddle.getWidth()) {
    //         let isBehindL = true;
    //     } else {
    //         let isBehindL = false;
    //     }
    //     if (yt > leftPaddle.getY() | yt = leftPaddle.getY()) {
    //         let isAboveLeftTop = true;
    //     } else {
    //         let isAboveLeftTop = false;
    //     }
    //     if (yb < (leftPaddle.getY() + leftPaddle.getHeight()) | yb = (leftPaddle.getY() + leftPaddle.getHeight())) {
    //         let isBelowLeftBottom = true;
    //     } else {
    //         let isBelowLeftBottom = false;
    //     }
    //     // check
    //     if ((isBehindL) & (isAboveLeftTop) & (isBelowLeftBottom)) {
    //         return 1;
    //     }
    //     // no collision at all
    //     return 0;
    // }

    method void flipVelX (){
        do Output.moveCursor(10,10);
        do Output.printString("in flip ");
        let velX = velX * (-1);
        return;
    }

    method void reset () {
        let x = 512 / 2; // half screen width
        let y = (256 / 2) + 16; // half screen height
        // let r = 10;

        let velX = -velX; // opposite horizontal direction
        let velY = velY; // Initial vertical direction
        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    method int getX(){
        return x;
    }

    method int getY(){
        return y;
    }

    /**
    Sets a new vector. The component of the new vector perpendicular to the given normal is equal to this vector's. The component of the new vector parallel to the normal is the negation of this vector's. May be used to simulate semi-elastic collisions if flipping a velocity vector relative to the collision normal.
    */
    // method void flipVel (int Ax, int Ay) {
    //     var int normalX;
    //     var int normalY;
    //     var int normalMag;
    //     var int proj;
    //     var int newX;
    //     var int newY;

    //     let normalX = Ax;
    //     let normalY = Ay;
    //     let normalMag = Math.sqrt((normalX * normalX) + (normalY * normalY));
    //     let proj = ((x * normalX) + (y * normalY)) / normalMag;
    //     let newX = velX;
    //     let newY = velY;

    //     if (proj < 0) {
    //         // if projection is negative, vector opposes normal.
    //         // in this case, inverse it along the projection
    //         let newX = velX - ((normalX * 2 * proj) / normalMag);
    //         let newY = velY - ((normalY * 2 * proj) / normalMag);
    //     }

    //     let velX = newX;
    //     let velY = newY;
    //     return;
    // }
}